# 🧮 기수 정렬 (Radix Sort)

---

## 📘 개념 요약

**Radix Sort**는 숫자의 “자리수(digit)”를 기준으로 여러 번 정렬을 수행하는 **비교 기반이 아닌 정렬 알고리즘**
즉 `>` 나 `<` 같은 비교를 하지 않고
각 숫자의 자릿값을 이용해 “버킷(bucket)”에 분류하여 정렬한다.

### 💡 핵심 아이디어

1. 숫자들을 일의 자리, 십의 자리, 백의 자리… 순으로 정렬한다.
2. 각 자리수를 기준으로 **0~9까지 10개의 버킷**에 숫자를 나누고,
3. 버킷을 순서대로 합치며 정렬을 반복한다.

---

## ✏️ 예시로 보는 정렬 과정

예를 들어 다음과 같은 숫자 배열이 있다고 가정

```js
[1556, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29]
```

### Step 1️⃣ — 일의 자리 기준

| 자리수 |        버킷(0~9)       |  결과 |
| :-: | :------------------: | :-: |
|  0  |                      |     |
|  1  |                      |     |
|  2  |          902         |     |
|  3  |          593         |     |
|  4  |           4          |     |
|  5  |                      |     |
|  6  | 1556, 3556, 4386, 86 |     |
|  7  |     7, 8157, 9637    |     |
|  8  |          408         |     |
|  9  |          29          |     |

➡️ **합치면:**
`[902, 593, 4, 1556, 3556, 4386, 86, 7, 8157, 9637, 408, 29]`

---

### Step 2️⃣ — 십의 자리 기준

일의 자리 기준으로 정렬된 배열을 **다시 십의 자리**로 분류

➡️ 반복하면서 결국 **천의 자리**까지 정렬하면

🔹 최종 결과:

```js
[4, 7, 29, 86, 408, 593, 902, 1556, 3556, 4386, 8157, 9637]
```

---

## ⚙️ 핵심 보조 함수들

기수 정렬에서는 여러 **도우미 함수(helper function)** 가 필요

### 1️⃣ `getDigit(num, i)`

→ 주어진 숫자 `num`의 i번째 자리수를 반환 (오른쪽에서 0번째 시작)

```js
function getDigit(num, i) {
  return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;
}
```

**예시:**

```js
getDigit(7323, 0); // 3 (일의 자리)
getDigit(7323, 1); // 2 (십의 자리)
getDigit(7323, 2); // 3 (백의 자리)
getDigit(7323, 3); // 7 (천의 자리)
```

---

### 2️⃣ `digitCount(num)`

→ 숫자가 몇 자리인지 반환

```js
function digitCount(num) {
  if (num === 0) return 1;
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}
```

**예시:**

```js
digitCount(0);    // 1
digitCount(25);   // 2
digitCount(314);  // 3
digitCount(9637); // 4
```

---

### 3️⃣ `mostDigits(nums)`

→ 배열에서 가장 큰 자리수를 가진 숫자의 자리수를 반환

```js
function mostDigits(nums) {
  let maxDigits = 0;
  for (let i = 0; i < nums.length; i++) {
    maxDigits = Math.max(maxDigits, digitCount(nums[i]));
  }
  return maxDigits;
}
```

**예시:**

```js
mostDigits([23, 567, 89, 12234324, 90]); // 8
```

---

## 🧠 Radix Sort 전체 로직

```js
function radixSort(nums) {
  const maxDigitCount = mostDigits(nums);

  for (let k = 0; k < maxDigitCount; k++) {
    // 0~9까지의 빈 버킷 배열 생성
    let digitBuckets = Array.from({ length: 10 }, () => []);

    // 각 숫자를 현재 자리수 기준으로 버킷에 분류
    for (let i = 0; i < nums.length; i++) {
      const digit = getDigit(nums[i], k);
      digitBuckets[digit].push(nums[i]);
    }

    // 버킷을 0~9 순서로 합쳐서 새로운 배열로 만듦
    nums = [].concat(...digitBuckets);
  }

  return nums;
}
```

---

## 🧩 동작 예시

```js
const numbers = [1556, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29];

console.log(radixSort(numbers));
// [4, 7, 29, 86, 408, 593, 902, 1556, 3556, 4386, 8157, 9637]
```

---

## ⏱️ 복잡도 분석

| 구분           | 복잡도      | 설명                          |
| ------------ | -------- | --------------------------- |
| **시간 복잡도**   | O(n * k) | n = 배열 길이, k = 가장 긴 숫자의 자리수 |
| **공간 복잡도**   | O(n + k) | 버킷 배열 및 중간 저장소 필요           |
| **비교 사용 여부** | ❌ 없음     | 자릿수를 이용해 분류하므로 비교 연산 불필요    |

---

## ✅ 요약

| 항목            | 내용                                |
| ------------- | --------------------------------- |
| **정렬 방식**     | 비(非)비교 기반                         |
| **적용 대상**     | 정수 배열 (음수도 보정 가능)                 |
| **장점**        | 매우 빠름 (자리수 k가 작을 때)               |
| **단점**        | 문자열, 소수점, 범위가 넓은 데이터에는 부적합        |
| **평균 시간 복잡도** | O(nk) — 일반적인 O(n log n)보다 빠를 수 있음 |
