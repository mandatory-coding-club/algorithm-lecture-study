# 문제 해결 패턴

## 1. 빈도 카운터 (Frequency Counter)

### 문제
- **입력값**: `[1, 2, 3, 3], [1, 9, 4, 9]` → `true`
- **조건**: arr2의 모든 원소가 arr1의 제곱 값으로 대응

### 해결 방법
- **방법1 O(n²)**: 중첩 for문. arr1을 순회하면서 arr2에 존재하는지 indexOf로 확인, 있다면 arr2의 해당 값을 splice로 제거
- **방법2 O(n)**: 중첩되지 않은 for문. arr1에서 등장 빈도 카운팅, arr2에서 등장 빈도 카운팅

### 예제2: 애너그램
- **설명**: 항목 안의 문자들이 나타나는 정확한 횟수를 체크해야 함
- **예시 입력**:
  - `''`, `''` → `true`
  - `'aab'`, `'aba'` → `true`
  - `'rat'`, `'car'` → `false`

### 강사 해결 코드 흐름
1. if 글자 길이 일치 확인
2. str1에서 빈도 카운팅
3. str2 순회하면서 카운팅 객체 각각에 (-1), 순회할 때 0이 나오면 종료

---

## 2. 다중 포인터 패턴 (Multiple Pointers)

### 개념
포인터를 양쪽으로 이동시키거나 앞뒤에서 중앙으로 온다거나 하는 것

### 예제1: sumZero 문제
- **입력**: 오름차순으로 정렬된 배열
- **출력**: 합쳐서 0이 되는 최초의 쌍을 찾아서 반환
- **예시**: `[-3, -2, -1, 0, 1, 2, 3]` → `[-3, 3]`

### 해결법
- **O(n²)**: 중첩 for문으로 각 원소에 대해 일치하는 값을 찾기 위해 순회
- **O(n)**: 양쪽끝에 포인터 사용. 합이 양수면 우측 포인터를 이동, 합이 음수면 좌측 포인터를 이동

### 예제2: countUniqueValues
- **문제**: 오름차순 정렬된 배열 입력, 숫자 가짓수 출력
- **예시**: `[1, 1, 1, 2, 3, 3, 3]` → `3`
- **해결법 O(n)**: i index와 j index를 활용, j인덱스를 이동하면서 배열 앞쪽을 정렬. j가 끝에 갈 때 i index값이 가짓수가 됨.

---

## 3. 슬라이딩 윈도우 (Sliding Window)

### 적용 문제
- 가장 긴 고유 문자열 찾기 문제
- 배열에서 지정 길이 동안의 합이 가장 큰 구간 찾기 문제

### 해결 방법
- **O(n²)**: 이동하면서 4개씩 더하기
- **O(n)**: 시작 위치에서 합 구하기. 다음으로 할 과정은 0번째 값 지우고 num번째 값 더하기. 창문을 이동하면서 빼는 값과 더하는 값의 비교.